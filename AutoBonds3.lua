if getgenv().SkullHubDrBond1 then return end getgenv().SkullHubDrBond1 = true repeat task.wait() until game:IsLoaded() and game:GetService("ReplicatedStorage") and game:GetService("Workspace") local Players = game:GetService("Players") local player = Players.LocalPlayer local character = player.Character or player.CharacterAdded:Wait() local humanoid = character:WaitForChild("Humanoid") humanoid.HealthChanged:Connect(function(health) if health <= 0 then task.wait(40) end end) -- Main UI local Players = game:GetService("Players") local Lighting = game:GetService("Lighting") local CoreGui = game:GetService("CoreGui") local TweenService = game:GetService("TweenService") local blur = Instance.new("BlurEffect") blur.Size = 20 blur.Parent = Lighting local screenGui = Instance.new("ScreenGui") screenGui.Name = "SkullHubUI" screenGui.ResetOnSpawn = false screenGui.IgnoreGuiInset = true screenGui.Parent = CoreGui local mainFrame = Instance.new("Frame") mainFrame.Size = UDim2.new(1, 0, 1, 0) mainFrame.BackgroundTransparency = 1 mainFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 10) mainFrame.Parent = screenGui local compactButton = Instance.new("TextButton") compactButton.Size = UDim2.new(0, 60, 0, 60) compactButton.Position = UDim2.new(0.5, -30, 0, -80) compactButton.BackgroundColor3 = Color3.fromRGB(24, 24, 24) compactButton.Text = "▲" compactButton.TextColor3 = Color3.fromRGB(255, 255, 255) compactButton.Font = Enum.Font.FredokaOne compactButton.TextSize = 24 compactButton.Visible = false compactButton.Parent = mainFrame local compactCorner = Instance.new("UICorner") compactCorner.CornerRadius = UDim.new(1, 0) compactCorner.Parent = compactButton local compactStroke = Instance.new("UIStroke") compactStroke.Thickness = 2 compactStroke.Color = Color3.fromRGB(72, 138, 182) compactStroke.Transparency = 0.3 compactStroke.Parent = compactButton local uiContainer = Instance.new("Frame") uiContainer.Size = UDim2.new(0, 450, 0, 240) uiContainer.Position = UDim2.new(0.5, -225, 1, 100) uiContainer.BackgroundColor3 = Color3.fromRGB(24, 24, 24) uiContainer.BackgroundTransparency = 0.1 uiContainer.Parent = mainFrame local corner = Instance.new("UICorner") corner.CornerRadius = UDim.new(0, 16) corner.Parent = uiContainer local stroke = Instance.new("UIStroke") stroke.Thickness = 2 stroke.Color = Color3.fromRGB(72, 138, 182) stroke.Transparency = 0.3 stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border stroke.Parent = uiContainer local gradient = Instance.new("UIGradient") gradient.Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.fromRGB(72, 138, 182)), ColorSequenceKeypoint.new(1, Color3.fromRGB(35, 35, 35)) }) gradient.Rotation = 45 gradient.Parent = uiContainer local minimizeButton = Instance.new("TextButton") minimizeButton.Size = UDim2.new(0, 30, 0, 30) minimizeButton.Position = UDim2.new(1, -40, 0, 10) minimizeButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50) minimizeButton.Text = "-" minimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255) minimizeButton.Font = Enum.Font.FredokaOne minimizeButton.TextSize = 20 minimizeButton.Parent = uiContainer local minimizeCorner = Instance.new("UICorner") minimizeCorner.CornerRadius = UDim.new(0, 8) minimizeCorner.Parent = minimizeButton local icon = Instance.new("ImageLabel") icon.Size = UDim2.new(0, 64, 0, 64) icon.Position = UDim2.new(0.5, -32, 0, 16) icon.BackgroundTransparency = 1 icon.Image = "rbxassetid://95183678717613" icon.Parent = uiContainer local title = Instance.new("TextLabel") title.Size = UDim2.new(1, -20, 0, 40) title.Position = UDim2.new(0, 10, 0, 90) title.BackgroundTransparency = 1 title.Text = "Skull Hub" title.TextColor3 = Color3.fromRGB(255, 255, 255) title.Font = Enum.Font.FredokaOne title.TextSize = 32 title.TextXAlignment = Enum.TextXAlignment.Center title.Parent = uiContainer local desc = Instance.new("TextLabel") desc.Size = UDim2.new(1, -40, 0, 60) desc.Position = UDim2.new(0, 20, 0, 140) desc.BackgroundTransparency = 1 desc.Text = "Auto farm bonds & win is running...\nPlease do not touch or movement the camera.\n(discord.gg/skullhub)" desc.TextColor3 = Color3.fromRGB(180, 180, 180) desc.Font = Enum.Font.FredokaOne desc.TextSize = 16 desc.TextWrapped = true desc.TextYAlignment = Enum.TextYAlignment.Top desc.TextXAlignment = Enum.TextXAlignment.Center desc.Parent = uiContainer local isMinimized = false local function toggleMinimize() isMinimized = not isMinimized if isMinimized then -- Minimize animation TweenService:Create(uiContainer, TweenInfo.new(0.4, Enum.EasingStyle.Sine, Enum.EasingDirection.In), { Position = UDim2.new(0.5, -225, 0, -300), Size = UDim2.new(0, 450, 0, 0) }):Play() TweenService:Create(mainFrame, TweenInfo.new(0.4, Enum.EasingStyle.Sine, Enum.EasingDirection.In), { BackgroundTransparency = 1 }):Play() task.wait(0.2) compactButton.Visible = true TweenService:Create(compactButton, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), { Position = UDim2.new(0.5, -30, 0, 10) }):Play() blur.Size = 0 minimizeButton.Text = "+" else -- Maximize animation TweenService:Create(compactButton, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.In), { Position = UDim2.new(0.5, -30, 0, -80) }):Play() task.wait(0.2) compactButton.Visible = false TweenService:Create(uiContainer, TweenInfo.new(0.6, Enum.EasingStyle.Back, Enum.EasingDirection.Out), { Position = UDim2.new(0.5, -225, 0.5, -120), Size = UDim2.new(0, 450, 0, 240) }):Play() TweenService:Create(mainFrame, TweenInfo.new(0.4, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), { BackgroundTransparency = 0.4 }):Play() blur.Size = 20 minimizeButton.Text = "-" end end minimizeButton.MouseButton1Click:Connect(toggleMinimize) compactButton.MouseButton1Click:Connect(toggleMinimize) task.wait(0.1) TweenService:Create(mainFrame, TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), { BackgroundTransparency = 0.4 }):Play() TweenService:Create(uiContainer, TweenInfo.new(0.6, Enum.EasingStyle.Back, Enum.EasingDirection.Out), { Position = UDim2.new(0.5, -225, 0.5, -120) }):Play() local function updateDescription(newText) local fadeOut = TweenService:Create(desc, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.In), { TextTransparency = 1 }) local fadeIn = TweenService:Create(desc, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), { TextTransparency = 0 }) fadeOut:Play() fadeOut.Completed:Connect(function() desc.Text = newText fadeIn:Play() end) end -- Notification UI local CoreGui = game:GetService("CoreGui") local TweenService = game:GetService("TweenService") local gui = CoreGui:FindFirstChild("ModernNotificationUI") or Instance.new("ScreenGui") gui.Name = "ModernNotificationUI" gui.ResetOnSpawn = false gui.IgnoreGuiInset = true gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling gui.DisplayOrder = 999999 gui.Parent = CoreGui local container = gui:FindFirstChild("NotificationContainer") or Instance.new("Frame") container.Name = "NotificationContainer" container.AnchorPoint = Vector2.new(1, 1) container.Size = UDim2.new(0, 320, 1, -20) container.Position = UDim2.new(1, -20, 1, -20) container.BackgroundTransparency = 1 container.Parent = gui if not container:FindFirstChild("Scale") then local scale = Instance.new("UIScale") scale.Name = "Scale" scale.Scale = 1 scale.Parent = container end local layout = container:FindFirstChildOfClass("UIListLayout") or Instance.new("UIListLayout") layout.Padding = UDim.new(0, 10) layout.SortOrder = Enum.SortOrder.LayoutOrder layout.VerticalAlignment = Enum.VerticalAlignment.Bottom layout.Parent = container local function notify(titleText, messageText, duration) duration = duration or 5 local notif = Instance.new("Frame") notif.Size = UDim2.new(1, 0, 0, 0) notif.BackgroundColor3 = Color3.fromRGB(30, 30, 30) notif.BackgroundTransparency = 1 notif.LayoutOrder = -tick() notif.ClipsDescendants = true notif.Parent = container local corner = Instance.new("UICorner") corner.CornerRadius = UDim.new(0, 12) corner.Parent = notif local stroke = Instance.new("UIStroke") stroke.Color = Color3.fromRGB(80, 160, 200) stroke.Thickness = 1 stroke.Transparency = 0.5 stroke.Parent = notif local title = Instance.new("TextLabel") title.Size = UDim2.new(1, -40, 0, 22) title.Position = UDim2.new(0, 14, 0, 10) title.BackgroundTransparency = 1 title.Text = titleText title.TextColor3 = Color3.fromRGB(255, 255, 255) title.Font = Enum.Font.FredokaOne title.TextSize = 18 title.TextXAlignment = Enum.TextXAlignment.Left title.Parent = notif local message = Instance.new("TextLabel") message.Size = UDim2.new(1, -40, 0, 40) message.Position = UDim2.new(0, 14, 0, 32) message.BackgroundTransparency = 1 message.Text = messageText message.TextColor3 = Color3.fromRGB(200, 200, 200) message.Font = Enum.Font.FredokaOne message.TextSize = 14 message.TextWrapped = true message.TextXAlignment = Enum.TextXAlignment.Left message.TextYAlignment = Enum.TextYAlignment.Top message.Parent = notif local closeBtn = Instance.new("TextButton") closeBtn.Size = UDim2.new(0, 22, 0, 22) closeBtn.Position = UDim2.new(1, -30, 0, 10) closeBtn.Text = "✕" closeBtn.TextColor3 = Color3.fromRGB(255, 100, 100) closeBtn.BackgroundTransparency = 1 closeBtn.Font = Enum.Font.FredokaOne closeBtn.TextSize = 18 closeBtn.ZIndex = 2 closeBtn.Parent = notif local progressBar = Instance.new("Frame") progressBar.Size = UDim2.new(1, -16, 0, 4) progressBar.Position = UDim2.new(0, 8, 1, -8) progressBar.BackgroundColor3 = Color3.fromRGB(128, 128, 128) progressBar.BackgroundTransparency = 0.7 progressBar.ZIndex = 2 progressBar.Parent = notif local progressCorner = Instance.new("UICorner") progressCorner.CornerRadius = UDim.new(0, 2) progressCorner.Parent = progressBar local progressFill = Instance.new("Frame") progressFill.Size = UDim2.new(1, 0, 1, 0) progressFill.BackgroundTransparency = 0 progressFill.Parent = progressBar local progressGradient = Instance.new("UIGradient") progressGradient.Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.fromRGB(80, 160, 200)), ColorSequenceKeypoint.new(1, Color3.fromRGB(50, 100, 140)) }) progressGradient.Parent = progressFill local progressFillCorner = Instance.new("UICorner") progressFillCorner.CornerRadius = UDim.new(0, 2) progressFillCorner.Parent = progressFill TweenService:Create(notif, TweenInfo.new(0.25, Enum.EasingStyle.Quad), { Size = UDim2.new(1, 0, 0, 80), BackgroundTransparency = 0 }):Play() TweenService:Create(progressFill, TweenInfo.new(duration, Enum.EasingStyle.Linear), { Size = UDim2.new(0, 0, 1, 0) }):Play() local function close() local tween = TweenService:Create(notif, TweenInfo.new(0.25, Enum.EasingStyle.Quad), { Size = UDim2.new(1, 0, 0, 0), BackgroundTransparency = 1 }) tween:Play() tween.Completed:Wait() notif:Destroy() end closeBtn.MouseButton1Click:Connect(close) task.delay(duration, function() if notif and notif.Parent then close() end end) end notify("Skull Hub", "This's just beta version, so there may be some errors/bugs. But don't worry you still can afk overnight!", 10) if game.PlaceId == 70876832253163 or game.PlaceId == 98018823628597 then local player = game:GetService("Players").LocalPlayer local character = player.Character or player.CharacterAdded:Wait() local rootPart = character:WaitForChild("HumanoidRootPart") -- Anchor player local function anchorPlayer() if rootPart then rootPart.Anchored = true else warn("[Skull Hub] RootPart not found") end end -- Unanchor player local function unanchorPlayer() if rootPart then rootPart.Anchored = false end end local args = { [1] = false } game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("EndDecision"):FireServer(unpack(args)) task.wait(3) local Players = game:GetService("Players") local LocalPlayer = Players.LocalPlayer local function hasRevolver() local backpack = LocalPlayer:WaitForChild("Backpack") return backpack:FindFirstChild("Revolver") ~= nil end if hasRevolver() then local success, result = pcall(function() return loadstring(game:HttpGet('https://raw.githubusercontent.com/idksuss/clbonds/refs/heads/main/f'))() end) if not success then end task.wait(1) local crate = nil for _, v in pairs(workspace:GetDescendants()) do if v:IsA("Model") and v.Name == "OpenableCrate" then crate = v break end end if crate then game:GetService("ReplicatedStorage").Packages.RemotePromise.Remotes.C_ActivateObject:FireServer(crate) else warn("[Skull Hub] OpenableCrate not found!") end local Players = game:GetService("Players") local TweenService = game:GetService("TweenService") local CoreGui = game:GetService("CoreGui") local player = Players.LocalPlayer -- Create ScreenGui in CoreGui local screenGui = Instance.new("ScreenGui") screenGui.Name = "SkullHubCountdownUI" screenGui.IgnoreGuiInset = false screenGui.ResetOnSpawn = false screenGui.DisplayOrder = 9999 screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling screenGui.Parent = CoreGui -- Parent to CoreGui for FULL overlap -- Create Frame local frame = Instance.new("Frame") frame.Size = UDim2.new(0, 130, 0, 36) frame.Position = UDim2.new(0, 12, 0, 48) -- Below Roblox logo/chat frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25) frame.BackgroundTransparency = 0.2 frame.BorderSizePixel = 0 frame.ZIndex = 10 frame.Parent = screenGui -- Rounded corners local corner = Instance.new("UICorner") corner.CornerRadius = UDim.new(0, 8) corner.Parent = frame -- Text label local label = Instance.new("TextLabel") label.Size = UDim2.new(1, 0, 1, 0) label.BackgroundTransparency = 1 label.Text = "10:00" label.Font = Enum.Font.FredokaOne label.TextColor3 = Color3.fromRGB(255, 255, 255) label.TextScaled = true label.ZIndex = 11 label.Parent = frame -- Countdown logic local totalTime = 10 * 60 local function formatTime(seconds) local mins = math.floor(seconds / 60) local secs = seconds % 60 return string.format("%02d:%02d", mins, secs) end local function pulse() local tween = TweenService:Create( label, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextColor3 = Color3.fromRGB(255, 255, 100)} ) local revert = TweenService:Create( label, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {TextColor3 = Color3.fromRGB(255, 255, 255)} ) tween:Play() tween.Completed:Once(function() revert:Play() end) end -- Start countdown task.spawn(function() while math.floor(totalTime) > 0 do label.Text = formatTime(math.floor(totalTime)) pulse() totalTime -= 1 task.wait(1) end label.Text = "00:00" end) notify("Skull Hub", "AI auto bonds and farm win started!", 10) local Players = game:GetService("Players") local ReplicatedStorage = game:GetService("ReplicatedStorage") local Workspace = game:GetService("Workspace") local RunService = game:GetService("RunService") -- Try multiple possible remote names local possibleRemotes = { ReplicatedStorage:FindFirstChild("Packages") and ReplicatedStorage.Packages:FindFirstChild("RemotePromise") and ReplicatedStorage.Packages.RemotePromise:FindFirstChild("Remotes") and ReplicatedStorage.Packages.RemotePromise.Remotes:FindFirstChild("C_ActivateObject"), ReplicatedStorage:FindFirstChild("Packages") and ReplicatedStorage.Packages:FindFirstChild("ActivateObjectClient"), ReplicatedStorage:FindFirstChild("ActivateObject"), ReplicatedStorage:FindFirstChild("Interact"), ReplicatedStorage:FindFirstChild("C_Interact") } local remote = nil for i, r in ipairs(possibleRemotes) do if r then remote = r break end end if not remote then return end local function collectBonds() local player = Players.LocalPlayer local character = player.Character if not character or not character:FindFirstChild("HumanoidRootPart") then warn("[Skull Hub] Character or HumanoidRootPart not found!") return end -- Search for bonds in RuntimeItems or workspace local items = Workspace:FindFirstChild("RuntimeItems") and Workspace.RuntimeItems:GetChildren() or Workspace:GetDescendants() local bondFound = false for _, item in ipairs(items) do if item.Name == "Bond" or item.Name == "BondCalculated" then bondFound = true -- Try multiple FireServer argument formats pcall( function() remote:FireServer(item) end ) pcall( function() local bondPart = item:FindFirstChild("Part") or item:FindFirstChildOfClass("BasePart") if bondPart then remote:FireServer(bondPart) end end ) pcall( function() remote:FireServer(item.Position) end ) pcall( function() local prompt = item:FindFirstChildOfClass("ProximityPrompt") if prompt then remote:FireServer(prompt) end end ) task.wait(0.2) -- Delay to avoid rate limits end end if not bondFound then else end end -- Auto-pickup using Heartbeat local lastRun = 0 local connection connection = RunService.Heartbeat:Connect( function() local currentTime = tick() if currentTime - lastRun >= 0.5 then lastRun = currentTime task.spawn( function() -- Run in parallel pcall(collectBonds) end ) end end ) -- Clean up when the player leaves local player = Players.LocalPlayer local cleanupConnection = player.AncestryChanged:Connect( function() if not player:IsDescendantOf(game) then if connection then connection:Disconnect() connection = nil end cleanupConnection:Disconnect() end end ) local ReplicatedStorage = game:GetService("ReplicatedStorage") local Players = game:GetService("Players") local TweenService = game:GetService("TweenService") local PathfindingService = game:GetService("PathfindingService") local player = Players.LocalPlayer local character = player.Character or player.CharacterAdded:Wait() local humanoid = character:WaitForChild("Humanoid") local hrp = character:WaitForChild("HumanoidRootPart") local Camera = workspace.CurrentCamera or workspace:WaitForChild("Camera") local runtimeItems = workspace:WaitForChild("RuntimeItems") local countdownStartTime = tick() local autoCollectEnabled = true local gunConnection local gunTypes = { ["Revolver"] = true, ["Shotgun"] = true, ["Rifle"] = true, ["Navy Revolver"] = true, ["Mauser C96"] = true, ["Bolt Action Rifle"] = true, ["Electrocutioner"] = true, ["Sawed-Off Shotgun"] = true } local function getPickUpRemote() local path1 = ReplicatedStorage:FindFirstChild("Remotes", true) if path1 then local tool = path1:FindFirstChild("PickUpTool") or path1:FindFirstChild("PickUp") if tool then return tool end end for _, remote in ipairs(ReplicatedStorage:GetDescendants()) do if remote:IsA("RemoteEvent") and remote.Name:match("PickUp") then return remote end end return nil end local pickUpRemote = getPickUpRemote() local function collectGun(gun) if gun and gun:IsA("Model") and gunTypes[gun.Name] then if not pickUpRemote then pickUpRemote = getPickUpRemote() if not pickUpRemote then return end end pcall(function() pickUpRemote:FireServer(gun) end) end end local function collectGuns() for _, item in ipairs(runtimeItems:GetChildren()) do collectGun(item) end end local function startAutoCollect() if gunConnection then gunConnection:Disconnect() end if not pickUpRemote then pickUpRemote = getPickUpRemote() end gunConnection = runtimeItems.ChildAdded:Connect(function(child) if autoCollectEnabled then task.wait(0.1) collectGun(child) end end) end if true then collectGuns() startAutoCollect() else if gunConnection then gunConnection:Disconnect() gunConnection = nil end end runtimeItems.ChildRemoved:Connect(function() if autoCollectEnabled then collectGuns() end end) local originalJumpPower = humanoid.JumpPower local ShootRemote = ReplicatedStorage.Remotes.Weapon.Shoot local ReloadRemote = ReplicatedStorage.Remotes.Weapon.Reload local ammoFolder = workspace.StartingZone.Buildings.Gunsmith.AmmoTable.ShopItems local gunFolder = workspace.StartingZone.Buildings.Gunsmith.GunTable.ShopItems local RemoteEvent = ReplicatedStorage.Shared.Network.RemoteEvent local goldBar = runtimeItems:FindFirstChild("GoldBar") local AutoHeadshotEnabled = true local AutoReloadEnabled = true local GunAuraAllMobs = true local SEARCH_RADIUS = 1000 local HEADSHOT_DELAY = 0.1 local LocalPlayer = Players.LocalPlayer local Backpack = LocalPlayer:WaitForChild("Backpack") local Weapons = { ["Revolver"] = true, ["Rifle"] = true, ["Sawed-Off Shotgun"] = true, ["Bolt Action Rifle"] = true, ["Navy Revolver"] = true, ["Mauser"] = true, ["Shotgun"] = true } if getgenv().moveToPosition then warn("[Skull Hub] moveToPosition overwritten by external script, restoring") getgenv().moveToPosition = nil end local Players = game:GetService("Players") local LocalPlayer = Players.LocalPlayer local function moveToPosition(target) local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait() local humanoid = character:FindFirstChildOfClass("Humanoid") local hrp = character:FindFirstChild("HumanoidRootPart") if not humanoid or not hrp or humanoid.Health <= 0 or humanoid.WalkSpeed <= 0 then warn("[Skull Hub] Invalid movement pre-checks") return end local targetPosition, targetRotation if typeof(target) == "CFrame" then targetPosition = target.Position targetRotation = target.Rotation else targetPosition = target targetRotation = nil end local threshold = 1 local maxRetries = 5 local attempts = 0 while (hrp.Position - targetPosition).Magnitude > threshold and attempts < maxRetries do local finished = false humanoid:MoveTo(targetPosition) local conn conn = humanoid.MoveToFinished:Connect(function(success) finished = success end) local t = 0 while not finished and t < 2 do -- 2 seconds max wait per MoveTo if (hrp.Position - targetPosition).Magnitude <= threshold then break end t += 0.1 task.wait(0.1) end if conn then conn:Disconnect() end attempts += 1 end if targetRotation then local startCFrame = hrp.CFrame local endCFrame = CFrame.new(hrp.Position) * targetRotation local tweenTime = 0.01 for t = 0, 1, 0.002 / tweenTime do hrp.CFrame = startCFrame:Lerp(endCFrame, t) task.wait(0.002 / tweenTime) end hrp.CFrame = endCFrame end end getgenv().moveToPosition = moveToPosition local function tweenCamera(targetPosition, duration) local startCFrame = Camera.CFrame local endCFrame = CFrame.new(startCFrame.Position, targetPosition) local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut) local goal = {CFrame = endCFrame} local tween = TweenService:Create(Camera, tweenInfo, goal) tween:Play() tween.Completed:Wait() end local function restoreCamera() local head = character:FindFirstChild("Head") if head then local targetCFrame = CFrame.new(head.Position, head.Position + head.CFrame.LookVector) tweenCamera(targetCFrame.Position, 0.3) end end local function spamProximityPrompt() task.spawn(function() while humanoid and humanoid.Health > 0 and hrp do local region = Region3.new(hrp.Position - Vector3.new(15, 15, 15), hrp.Position + Vector3.new(15, 15, 15)) local parts = workspace:FindPartsInRegion3(region, nil, 100) local foundPrompt = false for _, part in ipairs(parts) do local prompt = part:FindFirstChildOfClass("ProximityPrompt") if prompt and prompt:IsA("ProximityPrompt") then foundPrompt = true if prompt.Enabled then print("[Skull Hub] Found prompt: " .. prompt.Name .. " at " .. tostring(prompt.Parent:GetFullName())) for attempt = 1, 3 do local success, err = pcall(function() fireproximityprompt(prompt) end) if success then if prompt.Name == "EndGame" then local moveSuccess, moveErr = pcall(function() task.wait(0.5) moveToPosition(CFrame.new(-327.421478, 2.99993873, -49043.6289, -0.998146236, 1.30250113e-08, 0.0608610846, 8.85811513e-09, 1, -6.87355026e-08, -0.0608610846, -6.80689638e-08, -0.998146236)) task.wait(5) anchorPlayer() task.wait(240) unanchorPlayer() end) if not moveSuccess then warn("[Skull Hub] Move failed to post-bond location: " .. tostring(moveErr)) end end break else warn("[Skull Hub] Failed to trigger prompt " .. prompt.Name .. " (attempt " .. attempt .. "/3): " .. tostring(err)) task.wait(0.2) end end else warn("[Skull Hub] Prompt " .. prompt.Name .. " is disabled") end end end if not foundPrompt then local crankModel = workspace:FindFirstChild("Baseplates", true) and workspace.Baseplates:FindFirstChild("FinalBasePlate", true) if crankModel then local endGamePrompt = crankModel:FindFirstChild("EndGame", true) if endGamePrompt and endGamePrompt:IsA("ProximityPrompt") then for attempt = 1, 3 do local success, err = pcall(function() fireproximityprompt(endGamePrompt) end) if success then local moveSuccess, moveErr = pcall(function() moveToPosition(CFrame.new(-327.421478, 2.99993873, -49043.6289, -0.998146236, 1.30250113e-08, 0.0608610846, 8.85811513e-09, 1, -6.87355026e-08, -0.0608610846, -6.80689638e-08, -0.998146236)) end) if not moveSuccess then warn("[Skull Hub] Move failed to post-bond location: " .. tostring(moveErr)) end break else warn("Failed to trigger EndGame prompt (attempt " .. attempt .. "/3): " .. tostring(err)) task.wait(0.2) end end else local remotes = ReplicatedStorage:GetDescendants() for _, remote in ipairs(remotes) do if (remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction")) and (remote.Name:lower():match("endgame") or remote.Name:lower():match("bridge") or remote.Name:lower():match("crank")) then warn("Attempting fallback remote: " .. remote.Name) pcall(function() if remote:IsA("RemoteEvent") then remote:FireServer() else remote:InvokeServer() end end) end end end end warn("No ProximityPrompt found within 15 studs") end task.wait(0.1) end end) end local function startCountdown() task.spawn(function() while true do if tick() - countdownStartTime >= 600 then if humanoid and humanoid.Health > 0 and hrp then if not moveToPosition then warn("[Skull Hub] moveToPosition undefined, cannot move to prompt") break end local success, err = pcall(function() moveToPosition(CFrame.new(-342.00238, 2.99993849, -49045.3867, 0.0515649654, 3.68182782e-08, 0.998669624, -5.56108795e-08, 1, -3.39959314e-08, -0.998669624, -5.37839e-08, 0.0515649654)) end) if not success then warn("[Skull Hub] Move failed to prompt location: " .. tostring(err)) end spamProximityPrompt() end break end task.wait(1) end end) end startCountdown() local function sellgold() moveToPosition(Vector3.new(141.937561, 0.859375417, 29925.373)) local sellPosition = Vector3.new(151.013901, 3.51926398, 29931.2871) tweenCamera(sellPosition, 0.3) local maxAttempts = 5 local positionTolerance = 0.2 local success = false if not goldBar or not goldBar.Parent then warn("[Skull Hub] GoldBar not found in RuntimeItems") restoreCamera() return end local goldPart = goldBar.PrimaryPart or goldBar:FindFirstChildWhichIsA("BasePart") if not goldPart then warn("[Skull Hub] No BasePart found in GoldBar model") restoreCamera() return end local function getSellZoneCFrame() local raycastParams = RaycastParams.new() raycastParams.FilterDescendantsInstances = {character, goldBar} raycastParams.FilterType = Enum.RaycastFilterType.Blacklist local origin = sellPosition + Vector3.new(0, 10, 0) local direction = Vector3.new(0, -10, 0) local result = workspace:Raycast(origin, direction, raycastParams) local sellY = result and result.Position.Y or 3.51926398 local goldBarHeight = goldBar:GetExtentsSize().Y or 2 return CFrame.new(sellPosition.X, sellY + goldBarHeight / 2, sellPosition.Z) * CFrame.Angles(-math.pi/2, 0, 0) end local sellCFrame = getSellZoneCFrame() local targetPosition = sellCFrame.Position for attempt = 1, maxAttempts do if not goldBar.Parent or not goldPart.Parent then warn("[Skull Hub] GoldBar gone mid-drag, attempt " .. attempt) restoreCamera() return end local dragSuccess, err = pcall(function() RemoteEvent.RequestStartDrag:FireServer(goldBar) end) if not dragSuccess then warn("[Skull Hub] Failed to start gold drag: " .. tostring(err)) task.wait(0.5) continue end task.wait(0.4) goldPart.CanCollide = false goldPart.CFrame = sellCFrame task.wait(0.1) local stopSuccess, stopErr = pcall(function() RemoteEvent.RequestStopDrag:FireServer() end) if not stopSuccess then warn("[Skull Hub] Failed to stop gold drag: " .. tostring(stopErr)) end task.wait(0.5) if not goldPart.Parent then warn("[Skull Hub] GoldBar gone post-drag, attempt " .. attempt) goldPart.CanCollide = true restoreCamera() return end local currentPosition = goldPart.Position local distanceVector = currentPosition - targetPosition local distance = distanceVector.Magnitude if distance <= positionTolerance then task.wait(0.1) goldPart.CanCollide = true success = true break else local dx, dy, dz = distanceVector.X, distanceVector.Y, distanceVector.Z warn("Gold bar misplaced: X=" .. dx .. ", Y=" .. dy .. ", Z=" .. dz .. ", distance=" .. distance .. ", retrying attempt " .. attempt + 1) goldPart.CanCollide = true task.wait(0.2) end end restoreCamera() if not success then warn("[Skull Hub] Failed to place gold bar after " .. maxAttempts .. " attempts") end end sellgold() task.wait(1) function fr() moveToPosition(CFrame.new(148.38147, 6.01334095, 29848.5996, -0.730615914, 4.20822595e-08, -0.68278873, 6.54086207e-08, 1, -8.35737168e-09, 0.68278873, -5.07662961e-08, -0.730615914)) local Players = game:GetService("Players") local player = Players.LocalPlayer local character = player.Character or player.CharacterAdded:Wait() local humanoid = character:WaitForChild("Humanoid", 5) humanoid:ChangeState(Enum.HumanoidStateType.Jumping) task.wait(1) local maxAmmo = 4 local sellZonePosition = Vector3.new(154.147247, 4.85212898, 29855.8965) local maxAttempts = 3 local positionTolerance = 0.2 local earlyTolerance = 0.3 if not ammoFolder then restoreCamera() return end local function getSellZoneCFrame() local raycastParams = RaycastParams.new() raycastParams.FilterDescendantsInstances = {character} raycastParams.FilterType = Enum.RaycastFilterType.Blacklist local origin = sellZonePosition + Vector3.new(0, 5, 0) local direction = Vector3.new(0, -10, 0) local result = workspace:Raycast(origin, direction, raycastParams) local sellY = result and result.Position.Y or 4.85212898 local ammoHeight = 1 return CFrame.new(sellZonePosition.X, sellY + ammoHeight / 2, sellZonePosition.Z, -1, 0, 0, 0, 1, 0, 0, 0, -1) end local targetCFrame = getSellZoneCFrame() local sellPosition = targetCFrame.Position tweenCamera(sellPosition, 0.3) local ammoCount = 0 for _, model in ipairs(ammoFolder:GetChildren()) do if model:IsA("Model") and model.Name == "RevolverAmmo" and ammoCount < maxAmmo then local function dragItem(model, itemName) if not model or not model.Parent then warn("[Skull Hub] " .. itemName .. " not found or destroyed") return false end local part = model:FindFirstChildWhichIsA("BasePart") if not part then warn("[Skull Hub] No BasePart found for " .. itemName) return false end local originalCanCollide = part.CanCollide for attempt = 1, maxAttempts do if not model.Parent then warn("[Skull Hub] " .. itemName .. " gone mid-drag, attempt " .. attempt) return false end local dragSuccess, err = pcall(function() RemoteEvent.RequestStartDrag:FireServer(model) end) if not dragSuccess then warn("[Skull Hub] Failed to start drag for " .. itemName .. ": " .. tostring(err)) task.wait(0.2) continue end task.wait(0.4) part.CanCollide = false part.CFrame = targetCFrame task.wait(0.1) local stopSuccess, stopErr = pcall(function() RemoteEvent.RequestStopDrag:FireServer() end) if not stopSuccess then warn("[Skull Hub] Failed to stop drag for " .. itemName .. ": " .. tostring(stopErr)) end task.wait(0.5) if not part.Parent then warn("[Skull Hub] " .. itemName .. " gone post-drag, attempt " .. attempt) part.CanCollide = originalCanCollide return false end local currentPosition = part.Position local distanceVector = currentPosition - sellPosition local distance = distanceVector.Magnitude if distance <= earlyTolerance then task.wait(0.1) part.CanCollide = originalCanCollide return true else local dx, dy, dz = distanceVector.X, distanceVector.Y, distanceVector.Z warn(itemName .. " misplaced: X=" .. dx .. ", Y=" .. dy .. ", Z=" .. dz .. ", distance=" .. distance .. ", retrying attempt " .. attempt + 1) part.CanCollide = originalCanCollide task.wait(0.2) end end warn("[Skull Hub] Failed to place " .. itemName .. " after " .. maxAttempts .. " attempts") part.CanCollide = originalCanCollide return false end if dragItem(model, "RevolverAmmo") then ammoCount += 1 end task.wait(0.2) if ammoCount >= maxAmmo then break end end end restoreCamera() if ammoCount < maxAmmo then warn("[Skull Hub] Only dragged " .. ammoCount .. " of " .. maxAmmo .. " RevolverAmmo") end local success, err = pcall(function() fireclickdetector(workspace.StartingZone.Buildings.Gunsmith.Counter.Register.Box.ClickDetector) end) if success then print("[Skull Hub] ClickDetector fired successfully") else warn("[Skull Hub] Failed to fire click detector: " .. tostring(err)) end task.wait(2) end fr() task.wait(0.5) local function patchWeapon(tool) if Weapons[tool.Name] then local config = tool:WaitForChild("WeaponConfiguration", 3) if config then local reload = config:FindFirstChild("ReloadDuration") if reload then reload.Value = 0 end end end end for _, tool in ipairs(Backpack:GetChildren()) do if tool:IsA("Tool") then patchWeapon(tool) end end Backpack.ChildAdded:Connect(function(tool) if tool:IsA("Tool") then patchWeapon(tool) end end) local function getEquippedSupportedWeapon() local char = LocalPlayer.Character if not char then return nil end for name, _ in pairs(Weapons) do local tool = char:FindFirstChild(name) if tool then return tool end end return nil end local function isNPC(obj) if not obj:IsA("Model") then return false end if workspace:FindFirstChild("Horse") and obj:IsDescendantOf(workspace.Horse) then return false end local hum = obj:FindFirstChildOfClass("Humanoid") if not hum or hum.Health <= 0 then return false end return obj:FindFirstChild("Head") and obj:FindFirstChild("HumanoidRootPart") and not Players:GetPlayerFromCharacter(obj) end local function findAllNPCsInRange() local npcs = {} for _, obj in ipairs(workspace:GetDescendants()) do if isNPC(obj) then local head = obj:FindFirstChild("Head") local dist = (head.Position - Camera.CFrame.Position).Magnitude if dist <= SEARCH_RADIUS then table.insert(npcs, { model = obj, hum = obj.Humanoid, head = head }) end end end table.sort(npcs, function(a, b) return (a.head.Position - Camera.CFrame.Position).Magnitude < (b.head.Position - Camera.CFrame.Position).Magnitude end) return npcs end local function autoHeadshotLoop() while AutoHeadshotEnabled do local tool = getEquippedSupportedWeapon() if tool then local npcs = GunAuraAllMobs and findAllNPCsInRange() or {} for _, npc in ipairs(npcs) do if npc.hum and npc.hum.Health > 0 then local pelletTable = {} if tool.Name:lower():find("shotgun") then for i = 1, 6 do pelletTable[tostring(i)] = npc.hum end else pelletTable["1"] = npc.hum end local shootArgs = { workspace:GetServerTimeNow(), tool, CFrame.new(npc.head.Position + Vector3.new(0, 1.5, 0), npc.head.Position), pelletTable } ShootRemote:FireServer(unpack(shootArgs)) if AutoReloadEnabled then ReloadRemote:FireServer(workspace:GetServerTimeNow(), tool) end end end end task.wait(HEADSHOT_DELAY) end end task.spawn(autoHeadshotLoop) local function equipRevolver() local backpack = player:FindFirstChild("Backpack") if backpack then local revolver = backpack:FindFirstChild("Revolver") if revolver then revolver.Parent = character end end end equipRevolver() local Player = game.Players.LocalPlayer if not Player.Character then Player.CharacterAdded:Wait() end local Character = Player.Character if Character and Character:FindFirstChild("HumanoidRootPart") then local HRP = Character.HumanoidRootPart local HUM = Character:FindFirstChildOfClass("Humanoid") local originalWalkSpeed = HUM.WalkSpeed HUM.WalkSpeed = 0 HRP.CFrame = CFrame.new(-424.45, 26.06, -49040.66) HRP.Anchored = true task.wait(0.5) for _, part in pairs(Character:GetDescendants()) do if part:IsA("BasePart") then part.Velocity = Vector3.new(0, 0, 0) end end task.wait(3) HRP.CFrame = CFrame.new(-447.38, 26.08, -48747.68) task.wait(0.5) for _, part in pairs(Character:GetDescendants()) do if part:IsA("BasePart") then part.Velocity = Vector3.new(0, 0, 0) end end task.wait(3) HRP.CFrame = CFrame.new(-312.17, 26.08, -48747.68) task.wait(0.5) for _, part in pairs(Character:GetDescendants()) do if part:IsA("BasePart") then part.Velocity = Vector3.new(0, 0, 0) end end task.wait(3) HRP.CFrame = CFrame.new(-424.45, 26.06, -49040.66) task.wait(2) HRP.Anchored = false HUM.WalkSpeed = originalWalkSpeed end task.wait(1) local player = Players.LocalPlayer local character = player.Character or player.CharacterAdded:Wait() local humanoid = character:WaitForChild("Humanoid") local function checkSeated() if humanoid.Sit then print("yep") else local Players = game:GetService("Players") local LocalPlayer = Players.LocalPlayer local character = LocalPlayer.Character if character and character:FindFirstChild("Humanoid") then character.Humanoid.Health = 0 task.wait(40) end task.wait(1) end end checkSeated() humanoid:ChangeState(Enum.HumanoidStateType.Jumping) task.wait(0.2) moveToPosition(Vector3.new(-440.21844482421875, 2.999939203262329, -49042.9609375)) local player = game.Players.LocalPlayer local character = player.Character or player.CharacterAdded:Wait() local hrp = character:FindFirstChild("HumanoidRootPart") if not hrp then hrp = character:WaitForChild("HumanoidRootPart") end hrp.CFrame = CFrame.new(Vector3.new(-440.21844482421875, 2.999939203262329, -49042.9609375)) task.wait(3) local function areAllNPCsDead() local npcs = findAllNPCsInRange() for _, npc in ipairs(npcs) do if npc.hum and npc.hum.Health > 0 then return false end end return true end local function getClosestBond() local itemsFolder = workspace:FindFirstChild("RuntimeItems") if not itemsFolder then return nil end local closestBond, closestPart local minDistance = math.huge for _, model in ipairs(itemsFolder:GetChildren()) do if model:IsA("Model") and model.Name == "Bond" then local bondPart = model:FindFirstChildWhichIsA("BasePart") if bondPart then local distance = (hrp.Position - bondPart.Position).Magnitude if distance < minDistance then minDistance = distance closestBond = model closestPart = bondPart end end end end return closestBond, closestPart end local function countBonds() local itemsFolder = workspace:FindFirstChild("RuntimeItems") if not itemsFolder then return 0 end local count = 0 for _, model in ipairs(itemsFolder:GetChildren()) do if model:IsA("Model") and model.Name == "Bond" then count += 1 end end return count end local function collectBondsWithCheck() local totalBefore = countBonds() local totalTried = 0 local totalSuccess = 0 while true do local model, bondPart = getClosestBond() if not model or not bondPart then break end totalTried += 1 local before = countBonds() bondPart.CanCollide = false bondPart.Anchored = false moveToPosition(bondPart.Position) ReplicatedStorage.Packages.RemotePromise.Remotes.C_ActivateObject:FireServer(model) task.wait(0.3) local after = countBonds() if after < before then totalSuccess += 1 end end local totalAfter = countBonds() if humanoid and humanoid.Health > 0 and hrp then local success, err = pcall(function() notify("Skull Hub", "Collected all bonds, moving to wait position.", 10) notify("Skull Hub", "Need to wait 10 minutes from script execution to activate crank of the bridge to end game.", 10) moveToPosition(CFrame.new(-327.421478, 2.99993873, -49043.6289, -0.998146236, 1.30250113e-08, 0.0608610846, 8.85811513e-09, 1, -6.87355026e-08, -0.0608610846, -6.80689638e-08, -0.998146236)) end) if not success then warn("[Skull Hub] Move failed to post-bond location: " .. tostring(err)) end end end task.spawn(function() while true do if areAllNPCsDead() then collectBondsWithCheck() break end task.wait(1) end end) else local success, result = pcall(function() return loadstring(game:HttpGet('https://raw.githubusercontent.com/idksuss/clbonds/refs/heads/main/f'))() end) if not success then end task.wait(1) local crate = nil for _, v in pairs(workspace:GetDescendants()) do if v:IsA("Model") and v.Name == "OpenableCrate" then crate = v break end end if crate then game:GetService("ReplicatedStorage").Packages.RemotePromise.Remotes.C_ActivateObject:FireServer(crate) else warn("[Skull Hub] OpenableCrate not found!") end local Players = game:GetService("Players") local TweenService = game:GetService("TweenService") local CoreGui = game:GetService("CoreGui") local player = Players.LocalPlayer local screenGui = Instance.new("ScreenGui") screenGui.Name = "SkullHubCountdownUI" screenGui.IgnoreGuiInset = false screenGui.ResetOnSpawn = false screenGui.DisplayOrder = 9999 screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling screenGui.Parent = CoreGui local frame = Instance.new("Frame") frame.Size = UDim2.new(0, 130, 0, 36) frame.Position = UDim2.new(0, 12, 0, 48) frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25) frame.BackgroundTransparency = 0.2 frame.BorderSizePixel = 0 frame.ZIndex = 10 frame.Parent = screenGui local corner = Instance.new("UICorner") corner.CornerRadius = UDim.new(0, 8) corner.Parent = frame local label = Instance.new("TextLabel") label.Size = UDim2.new(1, 0, 1, 0) label.BackgroundTransparency = 1 label.Text = "10:00" label.Font = Enum.Font.FredokaOne label.TextColor3 = Color3.fromRGB(255, 255, 255) label.TextScaled = true label.ZIndex = 11 label.Parent = frame local totalTime = 10 * 60 local function formatTime(seconds) local mins = math.floor(seconds / 60) local secs = seconds % 60 return string.format("%02d:%02d", mins, secs) end local function pulse() local tween = TweenService:Create( label, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextColor3 = Color3.fromRGB(255, 255, 100)} ) local revert = TweenService:Create( label, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {TextColor3 = Color3.fromRGB(255, 255, 255)} ) tween:Play() tween.Completed:Once(function() revert:Play() end) end task.spawn(function() while math.floor(totalTime) > 0 do label.Text = formatTime(math.floor(totalTime)) pulse() totalTime -= 1 task.wait(1) end label.Text = "00:00" end) notify("Skull Hub", "AI auto bonds and farm win started!", 10) local Players = game:GetService("Players") local ReplicatedStorage = game:GetService("ReplicatedStorage") local Workspace = game:GetService("Workspace") local RunService = game:GetService("RunService") local possibleRemotes = { ReplicatedStorage:FindFirstChild("Packages") and ReplicatedStorage.Packages:FindFirstChild("RemotePromise") and ReplicatedStorage.Packages.RemotePromise:FindFirstChild("Remotes") and ReplicatedStorage.Packages.RemotePromise.Remotes:FindFirstChild("C_ActivateObject"), ReplicatedStorage:FindFirstChild("Packages") and ReplicatedStorage.Packages:FindFirstChild("ActivateObjectClient"), ReplicatedStorage:FindFirstChild("ActivateObject"), ReplicatedStorage:FindFirstChild("Interact"), ReplicatedStorage:FindFirstChild("C_Interact") } local remote = nil for i, r in ipairs(possibleRemotes) do if r then remote = r break end end if not remote then return end local function collectBonds() local player = Players.LocalPlayer local character = player.Character if not character or not character:FindFirstChild("HumanoidRootPart") then warn("[Skull Hub] Character or HumanoidRootPart not found!") return end local items = Workspace:FindFirstChild("RuntimeItems") and Workspace.RuntimeItems:GetChildren() or Workspace:GetDescendants() local bondFound = false for _, item in ipairs(items) do if item.Name == "Bond" or item.Name == "BondCalculated" then bondFound = true pcall( function() remote:FireServer(item) end ) pcall( function() local bondPart = item:FindFirstChild("Part") or item:FindFirstChildOfClass("BasePart") if bondPart then remote:FireServer(bondPart) end end ) pcall( function() remote:FireServer(item.Position) end ) pcall( function() local prompt = item:FindFirstChildOfClass("ProximityPrompt") if prompt then remote:FireServer(prompt) end end ) task.wait(0.2) end end if not bondFound then else end end local lastRun = 0 local connection connection = RunService.Heartbeat:Connect( function() local currentTime = tick() if currentTime - lastRun >= 0.5 then lastRun = currentTime task.spawn( function() pcall(collectBonds) end ) end end ) local player = Players.LocalPlayer local cleanupConnection = player.AncestryChanged:Connect( function() if not player:IsDescendantOf(game) then if connection then connection:Disconnect() connection = nil end cleanupConnection:Disconnect() end end ) local ReplicatedStorage = game:GetService("ReplicatedStorage") local Players = game:GetService("Players") local TweenService = game:GetService("TweenService") local PathfindingService = game:GetService("PathfindingService") local player = Players.LocalPlayer local character = player.Character or player.CharacterAdded:Wait() local humanoid = character:WaitForChild("Humanoid") local hrp = character:WaitForChild("HumanoidRootPart") local Camera = workspace.CurrentCamera or workspace:WaitForChild("Camera") local runtimeItems = workspace:WaitForChild("RuntimeItems") local countdownStartTime = tick() local autoCollectEnabled = true local gunConnection local gunTypes = { ["Revolver"] = true, ["Shotgun"] = true, ["Rifle"] = true, ["Navy Revolver"] = true, ["Mauser C96"] = true, ["Bolt Action Rifle"] = true, ["Electrocutioner"] = true, ["Sawed-Off Shotgun"] = true } local function getPickUpRemote() local path1 = ReplicatedStorage:FindFirstChild("Remotes", true) if path1 then local tool = path1:FindFirstChild("PickUpTool") or path1:FindFirstChild("PickUp") if tool then return tool end end for _, remote in ipairs(ReplicatedStorage:GetDescendants()) do if remote:IsA("RemoteEvent") and remote.Name:match("PickUp") then return remote end end return nil end local pickUpRemote = getPickUpRemote() local function collectGun(gun) if gun and gun:IsA("Model") and gunTypes[gun.Name] then if not pickUpRemote then pickUpRemote = getPickUpRemote() if not pickUpRemote then return end end pcall(function() pickUpRemote:FireServer(gun) end) end end local function collectGuns() for _, item in ipairs(runtimeItems:GetChildren()) do collectGun(item) end end local function startAutoCollect() if gunConnection then gunConnection:Disconnect() end if not pickUpRemote then pickUpRemote = getPickUpRemote() end gunConnection = runtimeItems.ChildAdded:Connect(function(child) if autoCollectEnabled then task.wait(0.1) collectGun(child) end end) end if true then collectGuns() startAutoCollect() else if gunConnection then gunConnection:Disconnect() gunConnection = nil end end runtimeItems.ChildRemoved:Connect(function() if autoCollectEnabled then collectGuns() end end) local originalJumpPower = humanoid.JumpPower local ShootRemote = ReplicatedStorage.Remotes.Weapon.Shoot local ReloadRemote = ReplicatedStorage.Remotes.Weapon.Reload local ammoFolder = workspace.StartingZone.Buildings.Gunsmith.AmmoTable.ShopItems local gunFolder = workspace.StartingZone.Buildings.Gunsmith.GunTable.ShopItems local RemoteEvent = ReplicatedStorage.Shared.Network.RemoteEvent local goldBar = runtimeItems:FindFirstChild("GoldBar") local AutoHeadshotEnabled = true local AutoReloadEnabled = true local GunAuraAllMobs = true local SEARCH_RADIUS = 1000 local HEADSHOT_DELAY = 0.1 local LocalPlayer = Players.LocalPlayer local Backpack = LocalPlayer:WaitForChild("Backpack") local Weapons = { ["Revolver"] = true, ["Rifle"] = true, ["Sawed-Off Shotgun"] = true, ["Bolt Action Rifle"] = true, ["Navy Revolver"] = true, ["Mauser"] = true, ["Shotgun"] = true } if getgenv().moveToPosition then warn("[Skull Hub] moveToPosition overwritten by external script, restoring") getgenv().moveToPosition = nil end local Players = game:GetService("Players") local LocalPlayer = Players.LocalPlayer local function moveToPosition(target) local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait() local humanoid = character:FindFirstChildOfClass("Humanoid") local hrp = character:FindFirstChild("HumanoidRootPart") if not humanoid or not hrp or humanoid.Health <= 0 or humanoid.WalkSpeed <= 0 then warn("[Skull Hub] Invalid movement pre-checks") return end local targetPosition, targetRotation if typeof(target) == "CFrame" then targetPosition = target.Position targetRotation = target.Rotation else targetPosition = target targetRotation = nil end local threshold = 1 local maxRetries = 5 local attempts = 0 while (hrp.Position - targetPosition).Magnitude > threshold and attempts < maxRetries do local finished = false humanoid:MoveTo(targetPosition) local conn conn = humanoid.MoveToFinished:Connect(function(success) finished = success end) local t = 0 while not finished and t < 2 do -- 2 seconds max wait per MoveTo if (hrp.Position - targetPosition).Magnitude <= threshold then break end t += 0.1 task.wait(0.1) end if conn then conn:Disconnect() end attempts += 1 end if targetRotation then local startCFrame = hrp.CFrame local endCFrame = CFrame.new(hrp.Position) * targetRotation local tweenTime = 0.01 for t = 0, 1, 0.002 / tweenTime do hrp.CFrame = startCFrame:Lerp(endCFrame, t) task.wait(0.002 / tweenTime) end hrp.CFrame = endCFrame end end getgenv().moveToPosition = moveToPosition local function tweenCamera(targetPosition, duration) local startCFrame = Camera.CFrame local endCFrame = CFrame.new(startCFrame.Position, targetPosition) local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut) local goal = {CFrame = endCFrame} local tween = TweenService:Create(Camera, tweenInfo, goal) tween:Play() tween.Completed:Wait() end local function restoreCamera() local head = character:FindFirstChild("Head") if head then local targetCFrame = CFrame.new(head.Position, head.Position + head.CFrame.LookVector) tweenCamera(targetCFrame.Position, 0.3) end end local function spamProximityPrompt() task.spawn(function() while humanoid and humanoid.Health > 0 and hrp do local region = Region3.new(hrp.Position - Vector3.new(15, 15, 15), hrp.Position + Vector3.new(15, 15, 15)) local parts = workspace:FindPartsInRegion3(region, nil, 100) local foundPrompt = false for _, part in ipairs(parts) do local prompt = part:FindFirstChildOfClass("ProximityPrompt") if prompt and prompt:IsA("ProximityPrompt") then foundPrompt = true if prompt.Enabled then print("[Skull Hub] Found prompt: " .. prompt.Name .. " at " .. tostring(prompt.Parent:GetFullName())) for attempt = 1, 3 do local success, err = pcall(function() fireproximityprompt(prompt) end) if success then if prompt.Name == "EndGame" then local moveSuccess, moveErr = pcall(function() task.wait(0.5) moveToPosition(CFrame.new(-327.421478, 2.99993873, -49043.6289, -0.998146236, 1.30250113e-08, 0.0608610846, 8.85811513e-09, 1, -6.87355026e-08, -0.0608610846, -6.80689638e-08, -0.998146236)) task.wait(5) anchorPlayer() task.wait(240) unanchorPlayer() end) if not moveSuccess then warn("[Skull Hub] Move failed to post-bond location: " .. tostring(moveErr)) end end break else warn("[Skull Hub] Failed to trigger prompt " .. prompt.Name .. " (attempt " .. attempt .. "/3): " .. tostring(err)) task.wait(0.2) end end else warn("[Skull Hub] Prompt " .. prompt.Name .. " is disabled") end end end if not foundPrompt then local crankModel = workspace:FindFirstChild("Baseplates", true) and workspace.Baseplates:FindFirstChild("FinalBasePlate", true) if crankModel then local endGamePrompt = crankModel:FindFirstChild("EndGame", true) if endGamePrompt and endGamePrompt:IsA("ProximityPrompt") then for attempt = 1, 3 do local success, err = pcall(function() fireproximityprompt(endGamePrompt) end) if success then local moveSuccess, moveErr = pcall(function() moveToPosition(CFrame.new(-327.421478, 2.99993873, -49043.6289, -0.998146236, 1.30250113e-08, 0.0608610846, 8.85811513e-09, 1, -6.87355026e-08, -0.0608610846, -6.80689638e-08, -0.998146236)) end) if not moveSuccess then warn("[Skull Hub] Move failed to post-bond location: " .. tostring(moveErr)) end break else warn("Failed to trigger EndGame prompt (attempt " .. attempt .. "/3): " .. tostring(err)) task.wait(0.2) end end else local remotes = ReplicatedStorage:GetDescendants() for _, remote in ipairs(remotes) do if (remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction")) and (remote.Name:lower():match("endgame") or remote.Name:lower():match("bridge") or remote.Name:lower():match("crank")) then warn("Attempting fallback remote: " .. remote.Name) pcall(function() if remote:IsA("RemoteEvent") then remote:FireServer() else remote:InvokeServer() end end) end end end end warn("No ProximityPrompt found within 15 studs") end task.wait(0.1) end end) end local function startCountdown() task.spawn(function() while true do if tick() - countdownStartTime >= 600 then if humanoid and humanoid.Health > 0 and hrp then if not moveToPosition then warn("[Skull Hub] moveToPosition undefined, cannot move to prompt") break end local success, err = pcall(function() moveToPosition(CFrame.new(-342.00238, 2.99993849, -49045.3867, 0.0515649654, 3.68182782e-08, 0.998669624, -5.56108795e-08, 1, -3.39959314e-08, -0.998669624, -5.37839e-08, 0.0515649654)) end) if not success then warn("[Skull Hub] Move failed to prompt location: " .. tostring(err)) end spamProximityPrompt() end break end task.wait(1) end end) end startCountdown() local function sellgold() moveToPosition(Vector3.new(141.937561, 0.859375417, 29925.373)) local sellPosition = Vector3.new(151.013901, 3.51926398, 29931.2871) tweenCamera(sellPosition, 0.3) local maxAttempts = 5 local positionTolerance = 0.2 local success = false if not goldBar or not goldBar.Parent then warn("[Skull Hub] GoldBar not found in RuntimeItems") restoreCamera() return end local goldPart = goldBar.PrimaryPart or goldBar:FindFirstChildWhichIsA("BasePart") if not goldPart then warn("[Skull Hub] No BasePart found in GoldBar model") restoreCamera() return end local function getSellZoneCFrame() local raycastParams = RaycastParams.new() raycastParams.FilterDescendantsInstances = {character, goldBar} raycastParams.FilterType = Enum.RaycastFilterType.Blacklist local origin = sellPosition + Vector3.new(0, 10, 0) local direction = Vector3.new(0, -10, 0) local result = workspace:Raycast(origin, direction, raycastParams) local sellY = result and result.Position.Y or 3.51926398 local goldBarHeight = goldBar:GetExtentsSize().Y or 2 return CFrame.new(sellPosition.X, sellY + goldBarHeight / 2, sellPosition.Z) * CFrame.Angles(-math.pi/2, 0, 0) end local sellCFrame = getSellZoneCFrame() local targetPosition = sellCFrame.Position for attempt = 1, maxAttempts do if not goldBar.Parent or not goldPart.Parent then warn("[Skull Hub] GoldBar gone mid-drag, attempt " .. attempt) restoreCamera() return end local dragSuccess, err = pcall(function() RemoteEvent.RequestStartDrag:FireServer(goldBar) end) if not dragSuccess then warn("[Skull Hub] Failed to start gold drag: " .. tostring(err)) task.wait(0.5) continue end task.wait(0.4) goldPart.CanCollide = false goldPart.CFrame = sellCFrame task.wait(0.1) local stopSuccess, stopErr = pcall(function() RemoteEvent.RequestStopDrag:FireServer() end) if not stopSuccess then warn("[Skull Hub] Failed to stop gold drag: " .. tostring(stopErr)) end task.wait(0.5) if not goldPart.Parent then warn("[Skull Hub] GoldBar gone post-drag, attempt " .. attempt) goldPart.CanCollide = true restoreCamera() return end local currentPosition = goldPart.Position local distanceVector = currentPosition - targetPosition local distance = distanceVector.Magnitude if distance <= positionTolerance then task.wait(0.1) goldPart.CanCollide = true success = true break else local dx, dy, dz = distanceVector.X, distanceVector.Y, distanceVector.Z warn("Gold bar misplaced: X=" .. dx .. ", Y=" .. dy .. ", Z=" .. dz .. ", distance=" .. distance .. ", retrying attempt " .. attempt + 1) goldPart.CanCollide = true task.wait(0.2) end end restoreCamera() if not success then warn("[Skull Hub] Failed to place gold bar after " .. maxAttempts .. " attempts") end end sellgold() task.wait(1) function fr() moveToPosition(CFrame.new(146.899994, 6.01334143, 29864.4062, 0.737892389, -1.1835104e-09, -0.674918354, 1.62217351e-09, 1, 1.99713805e-11, 0.674918354, -1.10957143e-09, 0.737892389)) local Players = game:GetService("Players") local player = Players.LocalPlayer local character = player.Character or player.CharacterAdded:Wait() local humanoid = character:WaitForChild("Humanoid", 5) humanoid:ChangeState(Enum.HumanoidStateType.Jumping) task.wait(1) local maxAmmo = 2 local maxGuns = 1 local sellZonePosition = Vector3.new(154.147247, 4.85212898, 29855.8965) local maxAttempts = 2 local positionTolerance = 0.5 -- Increased for more leniency local earlyToleranceGun = 0.5 -- Adjusted for Revolver local earlyToleranceAmmo = 0.5 -- Adjusted for RevolverAmmo if not ammoFolder or not gunFolder then warn("[Skull Hub] AmmoFolder or GunFolder not found") restoreCamera() return end local function getSellZoneCFrame(itemHeight) local raycastParams = RaycastParams.new() raycastParams.FilterDescendantsInstances = {character} raycastParams.FilterType = Enum.RaycastFilterType.Blacklist local origin = sellZonePosition + Vector3.new(0, 5, 0) local direction = Vector3.new(0, -10, 0) local result = workspace:Raycast(origin, direction, raycastParams) local sellY = result and result.Position.Y or 4.85212898 return CFrame.new(sellZonePosition.X, sellY + itemHeight / 2, sellZonePosition.Z, -1, 0, 0, 0, 1, 0, 0, 0, -1) end local function dragItem(model, itemName, itemHeight, earlyTolerance) if not model or not model.Parent or not model:IsA("Model") then warn("[Skull Hub] " .. itemName .. " not found or invalid") return false end local part = model:FindFirstChildWhichIsA("BasePart") if not part then warn("[Skull Hub] No BasePart found for " .. itemName) return false end local originalCanCollide = part.CanCollide local targetCFrame = getSellZoneCFrame(itemHeight) local targetPosition = targetCFrame.Position for attempt = 1, maxAttempts do if not model.Parent or model.Parent ~= (itemName == "Revolver" and gunFolder or ammoFolder) then warn("[Skull Hub] " .. itemName .. " gone or moved, attempt " .. attempt) return false end print("[Skull Hub] Starting drag attempt " .. attempt .. " for " .. itemName .. ": " .. model:GetFullName()) local dragSuccess, err for retry = 1, 3 do dragSuccess, err = pcall(function() RemoteEvent.RequestStartDrag:FireServer(model) end) if dragSuccess then break else warn("[Skull Hub] Failed to start drag for " .. itemName .. " (retry " .. retry .. "/3): " .. tostring(err)) task.wait(0.5) end end if not dragSuccess then warn("[Skull Hub] Exhausted retries for starting drag of " .. itemName) task.wait(0.3) continue end task.wait(0.8) -- Increased for server sync part.CanCollide = false print("[Skull Hub] Tweening " .. itemName .. " to target position") local tweenInfo = TweenInfo.new(0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut) local tween = TweenService:Create(part, tweenInfo, {CFrame = targetCFrame}) tween:Play() tween.Completed:Wait() task.wait(0.2) local stopSuccess, stopErr for retry = 1, 3 do stopSuccess, stopErr = pcall(function() RemoteEvent.RequestStopDrag:FireServer() end) if stopSuccess then break else warn("[Skull Hub] Failed to stop drag for " .. itemName .. " (retry " .. retry .. "/3): " .. tostring(stopErr)) task.wait(0.5) end end if not stopSuccess then warn("[Skull Hub] Exhausted retries for stopping drag of " .. itemName) part.CanCollide = originalCanCollide task.wait(0.3) continue end task.wait(1) -- Increased for server registration if not part.Parent or not model.Parent then warn("[Skull Hub] " .. itemName .. " gone post-drag, attempt " .. attempt) part.CanCollide = originalCanCollide return false end local currentPosition = part.Position local distanceVector = currentPosition - targetPosition local distance = distanceVector.Magnitude if distance <= earlyTolerance then task.wait(0.2) part.CanCollide = originalCanCollide print("[Skull Hub] Successfully dragged " .. itemName .. " with distance " .. distance) return true else local dx, dy, dz = distanceVector.X, distanceVector.Y, distanceVector.Z warn(itemName .. " misplaced: X=" .. dx .. ", Y=" .. dy .. ", Z=" .. dz .. ", distance=" .. distance .. ", retrying attempt " .. attempt + 1) part.CanCollide = originalCanCollide task.wait(0.3) end end warn("[Skull Hub] Failed to place " .. itemName .. " after " .. maxAttempts .. " attempts") part.CanCollide = originalCanCollide return false end local targetCFrame = getSellZoneCFrame(1) local sellPosition = targetCFrame.Position tweenCamera(sellPosition, 0.3) print("[Skull Hub] Initial gunFolder contents:") for _, v in ipairs(gunFolder:GetChildren()) do print("[Skull Hub] - " .. v:GetFullName()) end local gunCount = 0 for _, model in ipairs(gunFolder:GetChildren()) do if model:IsA("Model") and model.Name == "Revolver" and gunCount < maxGuns then if not model.Parent or model.Parent ~= gunFolder then warn("[Skull Hub] Revolver model " .. model:GetFullName() .. " no longer in gunFolder, skipping") continue end task.wait(0.5) print("[Skull Hub] Attempting to drag Revolver: " .. model:GetFullName()) if dragItem(model, "Revolver", 2, earlyToleranceGun) then gunCount += 1 print("[Skull Hub] gunFolder contents after Revolver drag:") for _, v in ipairs(gunFolder:GetChildren()) do print("[Skull Hub] - " .. v:GetFullName()) end end task.wait(0.3) break end end moveToPosition(CFrame.new(148.38147, 6.01334095, 29848.5996, -0.730615914, 4.20822595e-08, -0.68278873, 6.54086207e-08, 1, -8.35737168e-09, 0.68278873, -5.07662961e-08, -0.730615914)) tweenCamera(sellPosition, 0.3) print("[Skull Hub] Initial ammoFolder contents:") for _, v in ipairs(ammoFolder:GetChildren()) do print("[Skull Hub] - " .. v:GetFullName()) end local ammoCount = 0 local draggedModels = {} local ammoModels = {} for _, model in ipairs(ammoFolder:GetChildren()) do if model:IsA("Model") and model.Name == "RevolverAmmo" and #ammoModels < maxAmmo then table.insert(ammoModels, model) end end print("[Skull Hub] Selected " .. #ammoModels .. " RevolverAmmo models for dragging") for i, model in ipairs(ammoModels) do if ammoCount >= maxAmmo then print("[Skull Hub] Reached maxAmmo limit (" .. maxAmmo .. "), stopping ammo drag") break end if not model.Parent or model.Parent ~= ammoFolder then warn("[Skull Hub] RevolverAmmo model " .. model:GetFullName() .. " no longer in ammoFolder, skipping") continue end if not draggedModels[model] then print("[Skull Hub] Attempting to drag RevolverAmmo #" .. (ammoCount + 1) .. ": " .. model:GetFullName()) if dragItem(model, "RevolverAmmo", 1, earlyToleranceAmmo) then draggedModels[model] = true ammoCount += 1 print("[Skull Hub] Successfully dragged RevolverAmmo #" .. ammoCount) print("[Skull Hub] ammoFolder contents after drag #" .. ammoCount .. ":") for _, v in ipairs(ammoFolder:GetChildren()) do print("[Skull Hub] - " .. v:GetFullName()) end end task.wait(1.5) -- Increased for server sync end end restoreCamera() if gunCount < maxGuns then warn("[Skull Hub] Only dragged " .. gunCount .. " of " .. maxGuns .. " Revolver") end if ammoCount < maxAmmo then warn("[Skull Hub] Only dragged " .. ammoCount .. " of " .. maxAmmo .. " RevolverAmmo") end local success, err = pcall(function() fireclickdetector(workspace.StartingZone.Buildings.Gunsmith.Counter.Register.Box.ClickDetector) end) if success then print("[Skull Hub] ClickDetector fired successfully") else warn("[Skull Hub] Failed to fire click detector: " .. tostring(err)) end task.wait(2) local backpack = game.Players.LocalPlayer:WaitForChild("Backpack") local revolver = backpack:FindFirstChild("Revolver") if revolver then print("[Skull Hub] Revolver found in Backpack, continuing") else warn("[Skull Hub] No Revolver in Backpack, resetting character") local char = game.Players.LocalPlayer.Character if char and char:FindFirstChild("Humanoid") then notify("Skull Hub", "Error! Reset character to start a new run.", 10) char.Humanoid.Health = 0 task.wait(30) else warn("[Skull Hub] Character or Humanoid not found for reset") end return end end fr() task.wait(0.5) local function patchWeapon(tool) if Weapons[tool.Name] then local config = tool:WaitForChild("WeaponConfiguration", 3) if config then local reload = config:FindFirstChild("ReloadDuration") if reload then reload.Value = 0 end end end end for _, tool in ipairs(Backpack:GetChildren()) do if tool:IsA("Tool") then patchWeapon(tool) end end Backpack.ChildAdded:Connect(function(tool) if tool:IsA("Tool") then patchWeapon(tool) end end) local function getEquippedSupportedWeapon() local char = LocalPlayer.Character if not char then return nil end for name, _ in pairs(Weapons) do local tool = char:FindFirstChild(name) if tool then return tool end end return nil end local function isNPC(obj) if not obj:IsA("Model") then return false end if workspace:FindFirstChild("Horse") and obj:IsDescendantOf(workspace.Horse) then return false end local hum = obj:FindFirstChildOfClass("Humanoid") if not hum or hum.Health <= 0 then return false end return obj:FindFirstChild("Head") and obj:FindFirstChild("HumanoidRootPart") and not Players:GetPlayerFromCharacter(obj) end local function findAllNPCsInRange() local npcs = {} for _, obj in ipairs(workspace:GetDescendants()) do if isNPC(obj) then local head = obj:FindFirstChild("Head") local dist = (head.Position - Camera.CFrame.Position).Magnitude if dist <= SEARCH_RADIUS then table.insert(npcs, { model = obj, hum = obj.Humanoid, head = head }) end end end table.sort(npcs, function(a, b) return (a.head.Position - Camera.CFrame.Position).Magnitude < (b.head.Position - Camera.CFrame.Position).Magnitude end) return npcs end local function autoHeadshotLoop() while AutoHeadshotEnabled do local tool = getEquippedSupportedWeapon() if tool then local npcs = GunAuraAllMobs and findAllNPCsInRange() or {} for _, npc in ipairs(npcs) do if npc.hum and npc.hum.Health > 0 then local pelletTable = {} if tool.Name:lower():find("shotgun") then for i = 1, 6 do pelletTable[tostring(i)] = npc.hum end else pelletTable["1"] = npc.hum end local shootArgs = { workspace:GetServerTimeNow(), tool, CFrame.new(npc.head.Position + Vector3.new(0, 1.5, 0), npc.head.Position), pelletTable } ShootRemote:FireServer(unpack(shootArgs)) if AutoReloadEnabled then ReloadRemote:FireServer(workspace:GetServerTimeNow(), tool) end end end end task.wait(HEADSHOT_DELAY) end end task.spawn(autoHeadshotLoop) local function equipRevolver() local backpack = player:FindFirstChild("Backpack") if backpack then local revolver = backpack:FindFirstChild("Revolver") if revolver then revolver.Parent = character end end end equipRevolver() local Player = game.Players.LocalPlayer if not Player.Character then Player.CharacterAdded:Wait() end local Character = Player.Character if Character and Character:FindFirstChild("HumanoidRootPart") then local HRP = Character.HumanoidRootPart local HUM = Character:FindFirstChildOfClass("Humanoid") local originalWalkSpeed = HUM.WalkSpeed HUM.WalkSpeed = 0 HRP.CFrame = CFrame.new(-424.45, 26.06, -49040.66) HRP.Anchored = true task.wait(0.5) for _, part in pairs(Character:GetDescendants()) do if part:IsA("BasePart") then part.Velocity = Vector3.new(0, 0, 0) end end task.wait(3) HRP.CFrame = CFrame.new(-447.38, 26.08, -48747.68) task.wait(0.5) for _, part in pairs(Character:GetDescendants()) do if part:IsA("BasePart") then part.Velocity = Vector3.new(0, 0, 0) end end task.wait(3) HRP.CFrame = CFrame.new(-312.17, 26.08, -48747.68) task.wait(0.5) for _, part in pairs(Character:GetDescendants()) do if part:IsA("BasePart") then part.Velocity = Vector3.new(0, 0, 0) end end task.wait(3) HRP.CFrame = CFrame.new(-424.45, 26.06, -49040.66) task.wait(2) HRP.Anchored = false HUM.WalkSpeed = originalWalkSpeed end task.wait(1) local player = Players.LocalPlayer local character = player.Character or player.CharacterAdded:Wait() local humanoid = character:WaitForChild("Humanoid") local function checkSeated() if humanoid.Sit then print("yep") else local Players = game:GetService("Players") local LocalPlayer = Players.LocalPlayer local character = LocalPlayer.Character if character and character:FindFirstChild("Humanoid") then character.Humanoid.Health = 0 task.wait(40) end task.wait(1) end end checkSeated() humanoid:ChangeState(Enum.HumanoidStateType.Jumping) task.wait(0.2) moveToPosition(Vector3.new(-440.21844482421875, 2.999939203262329, -49042.9609375)) local player = game.Players.LocalPlayer local character = player.Character or player.CharacterAdded:Wait() local hrp = character:FindFirstChild("HumanoidRootPart") if not hrp then hrp = character:WaitForChild("HumanoidRootPart") end hrp.CFrame = CFrame.new(Vector3.new(-440.21844482421875, 2.999939203262329, -49042.9609375)) task.wait(3) local function areAllNPCsDead() local npcs = findAllNPCsInRange() for _, npc in ipairs(npcs) do if npc.hum and npc.hum.Health > 0 then return false end end return true end local function getClosestItem() local itemsFolder = workspace:FindFirstChild("RuntimeItems") if not itemsFolder then return nil end local closestItem, closestPart, closestType local minDistance = math.huge for _, model in ipairs(itemsFolder:GetChildren()) do if model:IsA("Model") and (model.Name == "Bond" or model.Name == "RevolverAmmo") then local itemPart = model:FindFirstChildWhichIsA("BasePart") if itemPart then local distance = (hrp.Position - itemPart.Position).Magnitude local priority = model.Name == "Bond" and 1 or 2 if priority == 1 or (priority == 2 and minDistance == math.huge) then if distance < minDistance then minDistance = distance closestItem = model closestPart = itemPart closestType = model.Name end end end end end return closestItem, closestPart, closestType end local function countItems() local itemsFolder = workspace:FindFirstChild("RuntimeItems") if not itemsFolder then return 0 end local count = 0 for _, model in ipairs(itemsFolder:GetChildren()) do if model:IsA("Model") and (model.Name == "Bond" or model.Name == "RevolverAmmo") then count += 1 end end return count end local function collectItemsWithCheck() local totalBefore = countItems() local totalTried = 0 local totalSuccess = 0 while true do local model, itemPart, itemType = getClosestItem() if not model or not itemPart then break end totalTried += 1 local before = countItems() itemPart.CanCollide = false itemPart.Anchored = false print("[Skull Hub] Moving to collect " .. itemType .. " at position " .. tostring(itemPart.Position)) moveToPosition(itemPart.Position) ReplicatedStorage.Packages.RemotePromise.Remotes.C_ActivateObject:FireServer(model) task.wait(0.3) local after = countItems() if after < before then totalSuccess += 1 print("[Skull Hub] Successfully collected " .. itemType) else warn("[Skull Hub] Failed to collect " .. itemType .. ", item may have despawned") end end local totalAfter = countItems() if humanoid and humanoid.Health > 0 and hrp then local success, err = pcall(function() notify("Skull Hub", "Collected all bonds and ammo, moving to wait position.", 10) notify("Skull Hub", "Need to wait 10 minutes from script execution to activate crank of the bridge to end game.", 10) moveToPosition(CFrame.new(-327.421478, 2.99993873, -49043.6289, -0.998146236, 1.30250113e-08, 0.0608610846, 8.85811513e-09, 1, -6.87355026e-08, -0.0608610846, -6.80689638e-08, -0.998146236)) end) if not success then warn("[Skull Hub] Move failed to post-item location: " .. tostring(err)) end end end task.spawn(function() while true do if areAllNPCsDead() then collectItemsWithCheck() break end task.wait(1) end end) end else local TweenService = game:GetService("TweenService") local Players = game:GetService("Players") local ReplicatedStorage = game:GetService("ReplicatedStorage") local player = Players.LocalPlayer local function getCharacter() return player.Character or player.CharacterAdded:Wait() end local function getHumanoidRootPart() local character = getCharacter() return character:WaitForChild("HumanoidRootPart") end local function getHumanoid() local character = getCharacter() return character:WaitForChild("Humanoid") end local function findTeleportZone() while true do for _, zone in ipairs(workspace.TeleportZones:GetChildren()) do local stateLabel = zone:FindFirstChild("BillboardGui") and zone.BillboardGui:FindFirstChild("StateLabel") if stateLabel and stateLabel.Text == "Waiting for players..." then return zone.PrimaryPart end end task.wait(1) end end local function walkTo(destination) local humanoidRootPart = getHumanoidRootPart() local humanoid = getHumanoid() local startPosition = humanoidRootPart.Position local targetPosition = Vector3.new(destination.Position.X, startPosition.Y, destination.Position.Z) local distance = (startPosition - targetPosition).Magnitude local timeToWalk = distance / 16 local tweenInfo = TweenInfo.new(timeToWalk, Enum.EasingStyle.Linear, Enum.EasingDirection.Out) local goal = { Position = targetPosition } local tween = TweenService:Create(humanoidRootPart, tweenInfo, goal) local running = true tween:Play() task.spawn(function() while running do local foundValidZone = false for _, zone in ipairs(workspace.TeleportZones:GetChildren()) do local stateLabel = zone:FindFirstChild("BillboardGui") and zone.BillboardGui:FindFirstChild("StateLabel") if stateLabel and stateLabel.Text == "Waiting for players..." then foundValidZone = true break end end if not foundValidZone then tween:Cancel() running = false break end task.wait(0.5) end end) tween.Completed:Wait() running = false humanoid:MoveTo(targetPosition) end local RunService = game:GetService("RunService") local ReplicatedStorage = game:GetService("ReplicatedStorage") local lastCheck = 0 RunService.Heartbeat:Connect(function() local now = tick() if now - lastCheck >= 1 then lastCheck = now local teleportDestination = findTeleportZone() walkTo(teleportDestination) local stateLabel = teleportDestination.Parent:FindFirstChild("BillboardGui") and teleportDestination.Parent.BillboardGui:FindFirstChild("StateLabel") if stateLabel and stateLabel.Text == "Waiting for players..." then local args = { [1] = { ["maxPlayers"] = 1, ["gameMode"] = "Normal" } } ReplicatedStorage:WaitForChild("Shared"):WaitForChild("RemotePromise"):WaitForChild("Remotes"):WaitForChild("C_CreateParty"):FireServer(unpack(args)) end end end) end getgenv().antiAfkEnabled = true local afkConnection local function startAntiAfk() local player = game:GetService("Players").LocalPlayer local virtualUser = game:GetService("VirtualUser") if afkConnection then afkConnection:Disconnect() end afkConnection = player.Idled:Connect(function() if getgenv().antiAfkEnabled then virtualUser:CaptureController() virtualUser:ClickButton2(Vector2.new()) -- Simulates user activity end end) end startAntiAfk() task.delay(960, function() local Players = game:GetService("Players") local LocalPlayer = Players.LocalPlayer local character = LocalPlayer.Character if character and character:FindFirstChild("Humanoid") then character.Humanoid.Health = 0 task.wait(40) end end)
